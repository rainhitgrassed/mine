local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/rainhitgrassed/mine/main/Source')))()
local Window = OrionLib:MakeWindow({Name = "Shadow.cc Free", HidePremium = false, SaveConfig = true, ConfigFolder = "OrionTest"})

local tab1 = Window:MakeTab({
	Name = "Main",
	Icon = "rbxassetid://4483362458",
	PremiumOnly = false
})

local sec1 = tab1:AddSection({
	Name = "Catching Settings"
})

local hitboxSize = 0 -- To change the football size
local isMagnetActive = false -- To check if the magnet toggle is active

local function resizePart(part)
    if part:IsA("BasePart") and (part.Name == "Football" or part.Name == "FootballBasePart") then
        if isMagnetActive then
            part.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
        end
    end
end

Workspace.ChildAdded:Connect(function(child)
    resizePart(child)
end)

for _, child in pairs(Workspace:GetChildren()) do
    resizePart(child)
end

tab1:AddToggle({
    Name = "Customize Magnets",
    Default = false,
    Callback = function(Value)
        isMagnetActive = Value
        print("Magnet Toggle:", Value)
    end    
})

local function GetClosestFootball()
	local player = game.Players.LocalPlayer
	local character = player.Character
	local closestFootball = nil
	local shortestDistance = math.huge
	
	for _, part in ipairs(workspace:GetChildren()) do
		if part:IsA("Part") and part.Name == "Football" then
			local distance = (character.HumanoidRootPart.Position - part.Position).magnitude
			if distance < shortestDistance then
				shortestDistance = distance
				closestFootball = part
			end
		end
	end
	
	return closestFootball
end

local hitbox = Instance.new("Part")
hitbox.Size = Vector3.new(0, 0, 0)
hitbox.Anchored = true
hitbox.CanCollide = false
hitbox.Transparency = 1 -- Fully transparent initially
hitbox.Color = Color3.fromRGB(128, 128, 128) -- Gray color
hitbox.Parent = workspace

tab1:AddToggle({
	Name = "Show Hitbox",
	Default = false,
	Callback = function(Value)
		if Value then
			hitbox.Transparency = 0.5 -- Semi-transparent when toggle is ON
		else
			hitbox.Transparency = 1 -- Fully transparent when toggle is OFF
		end
	end    
})

game:GetService("RunService").Stepped:Connect(function()
	local closestFootball = GetClosestFootball()
	if closestFootball then
		hitbox.Position = closestFootball.Position
	end
end)

tab1:AddSlider({
    Name = "Magnet Radius",
    Min = 0,
    Max = 25,
    Default = 0,
    Color = Color3.fromRGB(109,22,197),
    Increment = 1,
    ValueName = "Magnet Radius",
    Callback = function(Value)
		hitbox.Size = Vector3.new(Value, Value, Value)
        hitboxSize = Value
        print("Magnet Radius:", Value)
        
        for _, child in pairs(Workspace:GetChildren()) do
            if child:IsA("BasePart") and (child.Name == "Football" or child.Name == "FootballBasePart") then
                resizePart(child)
            end
        end
    end    
})

local sec2 = tab1:AddSection({
	Name = "Player Settings"
})

tab1:AddToggle({
    Name = "Angle Enchantment",
    Default = false,
    Callback = function(Value)
        angleEnchantmentEnabled = Value
        print("Angle Enchantment:", Value)
    end    
})

local jumpPowerValue = 50

local function updatePlayerStats()
	local player = game.Players.LocalPlayer
	if player and player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
		local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
		humanoid.JumpPower = jumpPowerValue
	end
end

tab1:AddSlider({
	Name = "Jumppower",
	Min = 50,
	Max = 55,
	Default = 50,
	Color = Color3.fromRGB(109,22,197),
	Increment = 0.1,
	ValueName = "JP",
	Callback = function(Value)
		jumpPowerValue = Value
		updatePlayerStats()
	end    
})

game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
	local humanoid = character:WaitForChild("Humanoid")
	
	humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(updatePlayerStats)
	humanoid:GetPropertyChangedSignal("JumpPower"):Connect(updatePlayerStats)
	
	updatePlayerStats()
end)

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local originalJumpPower = humanoid.JumpPower
local temporaryJumpPower = 55
local resetDelay = 0.1 -- Time in seconds before resetting the jump power
local angleEnchantmentEnabled = false

tab1:AddSlider({
    Name = "Angle JP",
    Min = 55,
    Max = 59,
    Default = 55,
    Color = Color3.fromRGB(109,22,197),
    Increment = 0.1,
    ValueName = "JP",
    Callback = function(Value)
        temporaryJumpPower = Value
        print("Angle JP:", Value)
    end    
})

local function onKeyPress(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    
    if input.KeyCode == Enum.KeyCode.Space and UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
        if angleEnchantmentEnabled then
            humanoid.JumpPower = temporaryJumpPower
            wait(resetDelay)
            humanoid.JumpPower = originalJumpPower
        end
    end
end

UserInputService.InputBegan:Connect(onKeyPress)

local sec3 = tab1:AddSection({
	Name = "Physics Settings"
})

local player = game.Players.LocalPlayer
local userInputService = game:GetService("UserInputService")
local range = 0

-- Function to teleport the player
local function teleportPlayer()
    local character = player.Character
    if not character then return end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    local currentPosition = humanoidRootPart.Position
    local lookDirection = humanoidRootPart.CFrame.LookVector

    local newPosition = currentPosition + (lookDirection * range)
    
    humanoidRootPart.CFrame = CFrame.new(newPosition, newPosition + lookDirection)
end

userInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.F then
        teleportPlayer()
    end
end)


tab1:AddToggle({
	Name = "QuickTP",
	Default = false,
	Callback = function(Value)
		range = Value
	end    
})

tab1:AddSlider({
	Name = "QuickTP Range",
	Min = 0,
	Max = 5,
	Default = 0,
	Color = Color3.fromRGB(109,22,197),
	Increment = 1,
	ValueName = "TP Range",
	Callback = function(Value)
		range = Value
	end    
})

local sec4 = tab1:AddSection({
	Name = "Visual Settings"
})

local grav = 28
local beamVisible = false  -- This variable will control the visibility of the beam

local function BallPosAtTime(initial_position, initial_velocity, gravity, t)
    local predicted_position = initial_position + initial_velocity * t + 0.5 * Vector3.new(0, -gravity, 0) * t ^ 2
    return predicted_position
end

local function createPartsAndBeam(x0, v0, airtime)
    local parts = {}
    local attachments = {}
    local lastAttachment = nil

    for t = 0, airtime, 0.05 do
        local POS = BallPosAtTime(x0, v0, grav, t)
        local Part = Instance.new("Part")
        Part.Parent = workspace
        Part.Size = Vector3.new(3, 2, 3)
        Part.Anchored = true
        Part.Color = Color3.fromRGB(0, 147, 70) -- Green color
        Part.CanCollide = false
        Part.Position = POS
        Part.Rotation = Vector3.new(-90, 0, 90)
        Part.Transparency = 1 -- Make the part completely invisible
        table.insert(parts, Part)

        local attachment = Instance.new("Attachment", Part)
        table.insert(attachments, attachment)

        if lastAttachment then
            local beam = Instance.new("Beam")
            beam.Parent = Part
            beam.Color = ColorSequence.new(Color3.fromRGB(192, 22, 197)) -- White color
            beam.Texture = "rbxassetid://18231379988"
            beam.Attachment0 = lastAttachment
            beam.Attachment1 = attachment
            beam.Width0 = 1.5
            beam.Width1 = 1.5
            beam.Transparency = NumberSequence.new(1 - (t / 0.5))
            beam.Enabled = beamVisible  -- Set beam visibility based on toggle
        end

        lastAttachment = attachment
    end
    return parts
end

workspace.ChildAdded:Connect(function(c)
    game:GetService("RunService").Stepped:Wait()
    if c.Name ~= "Football" or c:IsA("Tool") then return end

    local x0 = c.Position
    local v0 = c.Velocity

    local airtime = (-v0.Y - math.sqrt(v0.Y ^ 2 - 4 * 0.5 * -grav * x0.Y)) / (2 * 0.5 * -grav)

    local parts = createPartsAndBeam(x0, v0, airtime)

    task.wait(airtime + 1.75)

    for _, Part in ipairs(parts) do
        Part:Destroy()
    end
end)

-- Toggle for beam visibility
tab1:AddToggle({
    Name = "Ball Prediction",
    Default = false,
    Callback = function(Value)
        beamVisible = Value  -- Update the visibility based on toggle
        print("Beam visibility set to:", Value)
    end    
})
